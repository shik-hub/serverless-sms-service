"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const globals_1 = require("../globals");
const utils_1 = require("../utils");
const certStatuses = ["PENDING_VALIDATION", "ISSUED", "INACTIVE"];
class ACMWrapper {
    constructor(endpointType) {
        const credentials = globals_1.default.serverless.providers.aws.getCredentials();
        credentials.region = globals_1.default.defaultRegion;
        if (endpointType === globals_1.default.endpointTypes.regional) {
            credentials.region = globals_1.default.serverless.providers.aws.getRegion();
        }
        this.acm = new globals_1.default.serverless.providers.aws.sdk.ACM(credentials);
    }
    /**
     * * Gets Certificate ARN that most closely matches domain name OR given Cert ARN if provided
     */
    getCertArn(domain) {
        return __awaiter(this, void 0, void 0, function* () {
            let certificateArn; // The arn of the selected certificate
            let certificateName = domain.certificateName; // The certificate name
            try {
                const certificates = yield (0, utils_1.getAWSPagedResults)(this.acm, "listCertificates", "CertificateSummaryList", "NextToken", "NextToken", { CertificateStatuses: certStatuses });
                if (certificateName != null) {
                    certificateArn = yield this.getCertArnByCertName(certificates, certificateName);
                }
                else {
                    certificateName = domain.givenDomainName;
                    certificateArn = this.getCertArnByDomainName(certificates, certificateName);
                }
            }
            catch (err) {
                throw Error(`Could not search certificates in Certificate Manager.\n${err.message}`);
            }
            if (certificateArn == null) {
                throw Error(`Could not find an in-date certificate for '${certificateName}'.`);
            }
            return certificateArn;
        });
    }
    /**
     * * Gets Certificate ARN that most closely matches Cert ARN and not expired
     */
    getCertArnByCertName(certificates, certName) {
        return __awaiter(this, void 0, void 0, function* () {
            // note: we only check DomainName, but a future enhancement could
            // be to also check SubjectAlternativeNames
            const matches = certificates.filter((certificate) => (certificate.DomainName === certName));
            for (const certificate of matches) {
                const certificateArn = certificate.CertificateArn;
                const details = yield (0, utils_1.throttledCall)(this.acm, "describeCertificate", { CertificateArn: certificateArn });
                const currNotAfter = details.Certificate.NotAfter;
                if (Date.now() < currNotAfter) {
                    globals_1.default.logInfo(`Selecting cert with ARN=${certificateArn} with future expiry (${currNotAfter.toISOString()})`);
                    return certificateArn;
                }
                globals_1.default.logInfo(`Ignoring cert with ARN=${certificateArn} that is expired (${currNotAfter.toISOString()})`);
            }
        });
    }
    /**
     * * Gets Certificate ARN that most closely matches domain name
     */
    getCertArnByDomainName(certificates, domainName) {
        // The more specific name will be the longest
        let nameLength = 0;
        let certificateArn;
        certificates.forEach((certificate) => {
            let certificateListName = certificate.DomainName;
            // Looks for wild card and takes it out when checking
            if (certificateListName[0] === "*") {
                certificateListName = certificateListName.substring(1);
            }
            // Looks to see if the name in the list is within the given domain
            // Also checks if the name is more specific than previous ones
            if (domainName.includes(certificateListName) && certificateListName.length > nameLength) {
                nameLength = certificateListName.length;
                certificateArn = certificate.CertificateArn;
            }
        });
        return certificateArn;
    }
}
module.exports = ACMWrapper;
