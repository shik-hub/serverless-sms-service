"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const DomainInfo = require("../domain-info");
const globals_1 = require("../globals");
const aws_sdk_1 = require("aws-sdk");
const utils_1 = require("../utils");
class APIGatewayWrapper {
    constructor(credentials) {
        this.apiGateway = new aws_sdk_1.APIGateway(credentials);
        this.apiGatewayV2 = new aws_sdk_1.ApiGatewayV2(credentials);
    }
    /**
     * Creates Custom Domain Name through API Gateway
     * @param domain: DomainConfig
     */
    createCustomDomain(domain) {
        return __awaiter(this, void 0, void 0, function* () {
            const isEdgeType = domain.endpointType === globals_1.default.endpointTypes.edge;
            if (isEdgeType || domain.securityPolicy === globals_1.default.tlsVersions.tls_1_0) {
                // For EDGE domain name or TLS 1.0, create with APIGateway (v1)
                return new DomainInfo(yield this.createCustomDomainV1(domain));
            }
            else {
                // For Regional domain name create with ApiGatewayV2
                return new DomainInfo(yield this.createCustomDomainV2(domain));
            }
        });
    }
    /**
     * Creates Custom Domain Name through API Gateway V1
     * @param domain: DomainConfig
     */
    createCustomDomainV1(domain) {
        return __awaiter(this, void 0, void 0, function* () {
            const providerTags = Object.assign(Object.assign({}, globals_1.default.serverless.service.provider.stackTags), globals_1.default.serverless.service.provider.tags);
            const params = {
                domainName: domain.givenDomainName,
                endpointConfiguration: {
                    types: [domain.endpointType],
                },
                securityPolicy: domain.securityPolicy,
                tags: providerTags,
            };
            const isEdgeType = domain.endpointType === globals_1.default.endpointTypes.edge;
            if (isEdgeType) {
                params.certificateArn = domain.certificateArn;
            }
            else {
                params.regionalCertificateArn = domain.certificateArn;
                if (domain.tlsTruststoreUri) {
                    params.mutualTlsAuthentication = {
                        truststoreUri: domain.tlsTruststoreUri
                    };
                    if (domain.tlsTruststoreVersion) {
                        params.mutualTlsAuthentication.truststoreVersion = domain.tlsTruststoreVersion;
                    }
                }
            }
            try {
                return yield (0, utils_1.throttledCall)(this.apiGateway, "createDomainName", params);
            }
            catch (err) {
                throw new Error(`API Gateway V1 failed to create custom domain '${domain.givenDomainName}':\n${err.message}`);
            }
        });
    }
    /**
     * Creates Custom Domain Name through API Gateway V2
     * @param domain: DomainConfig
     */
    createCustomDomainV2(domain) {
        return __awaiter(this, void 0, void 0, function* () {
            const providerTags = Object.assign(Object.assign({}, globals_1.default.serverless.service.provider.stackTags), globals_1.default.serverless.service.provider.tags);
            const params = {
                DomainName: domain.givenDomainName,
                DomainNameConfigurations: [{
                        CertificateArn: domain.certificateArn,
                        EndpointType: domain.endpointType,
                        SecurityPolicy: domain.securityPolicy,
                    }],
                Tags: providerTags
            };
            const isEdgeType = domain.endpointType === globals_1.default.endpointTypes.edge;
            if (!isEdgeType && domain.tlsTruststoreUri) {
                params.MutualTlsAuthentication = {
                    TruststoreUri: domain.tlsTruststoreUri
                };
                if (domain.tlsTruststoreVersion) {
                    params.MutualTlsAuthentication.TruststoreVersion = domain.tlsTruststoreVersion;
                }
            }
            try {
                return yield (0, utils_1.throttledCall)(this.apiGatewayV2, "createDomainName", params);
            }
            catch (err) {
                throw new Error(`API Gateway V2 failed to create custom domain '${domain.givenDomainName}':\n${err.message}`);
            }
        });
    }
    /**
     * Delete Custom Domain Name through API Gateway
     */
    deleteCustomDomain(domain) {
        return __awaiter(this, void 0, void 0, function* () {
            // Make API call
            try {
                yield (0, utils_1.throttledCall)(this.apiGatewayV2, "deleteDomainName", {
                    DomainName: domain.givenDomainName,
                });
            }
            catch (err) {
                throw new Error(`Failed to delete custom domain '${domain.givenDomainName}':\n${err.message}`);
            }
        });
    }
    /**
     * Get Custom Domain Info through API Gateway
     */
    getCustomDomainInfo(domain) {
        return __awaiter(this, void 0, void 0, function* () {
            // Make API call
            try {
                const domainInfo = yield (0, utils_1.throttledCall)(this.apiGatewayV2, "getDomainName", {
                    DomainName: domain.givenDomainName,
                });
                return new DomainInfo(domainInfo);
            }
            catch (err) {
                if (err.code !== "NotFoundException") {
                    throw new Error(`Unable to fetch information about '${domain.givenDomainName}':\n${err.message}`);
                }
                globals_1.default.logInfo(`'${domain.givenDomainName}' does not exist.`);
            }
        });
    }
    /**
     * Creates basepath mapping
     */
    createBasePathMapping(domain) {
        return __awaiter(this, void 0, void 0, function* () {
            // Use APIGateway (v1) for EDGE or TLS 1.0 domains
            if (domain.endpointType === globals_1.default.endpointTypes.edge || domain.securityPolicy === "TLS_1_0") {
                const params = {
                    basePath: domain.basePath,
                    domainName: domain.givenDomainName,
                    restApiId: domain.apiId,
                    stage: domain.stage,
                };
                // Make API call
                try {
                    yield (0, utils_1.throttledCall)(this.apiGateway, "createBasePathMapping", params);
                    globals_1.default.logInfo(`Created API mapping '${domain.basePath}' for '${domain.givenDomainName}'`);
                }
                catch (err) {
                    throw new Error(`Make sure the '${domain.givenDomainName}' exists.
                     Unable to create base path mapping for '${domain.givenDomainName}':\n${err.message}`);
                }
            }
            else { // Use ApiGatewayV2 for Regional domains
                const params = {
                    ApiId: domain.apiId,
                    ApiMappingKey: domain.basePath,
                    DomainName: domain.givenDomainName,
                    Stage: domain.apiType === globals_1.default.apiTypes.http ? globals_1.default.defaultStage : domain.stage,
                };
                // Make API call
                try {
                    yield (0, utils_1.throttledCall)(this.apiGatewayV2, "createApiMapping", params);
                    globals_1.default.logInfo(`Created API mapping '${domain.basePath}' for '${domain.givenDomainName}'`);
                }
                catch (err) {
                    throw new Error(`Unable to create base path mapping for '${domain.givenDomainName}':\n${err.message}`);
                }
            }
        });
    }
    getApiMappings(domain) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield (0, utils_1.getAWSPagedResults)(this.apiGatewayV2, "getApiMappings", "Items", "NextToken", "NextToken", { DomainName: domain.givenDomainName });
            }
            catch (err) {
                throw new Error(`Make sure the '${domain.givenDomainName}' exists. Unable to get API Mappings:\n${err.message}`);
            }
        });
    }
    /**
     * Updates basepath mapping
     */
    updateBasePathMapping(domain) {
        return __awaiter(this, void 0, void 0, function* () {
            // Use APIGateway (v1) for EDGE or TLS 1.0 domains
            // check here if the EXISTING domain is using TLS 1.0 regardless of what is configured
            // We don't support updating custom domains so switching from TLS 1.0 to 1.2 will require recreating
            // the domain
            if (domain.endpointType === globals_1.default.endpointTypes.edge || domain.domainInfo.securityPolicy === "TLS_1_0") {
                const params = {
                    basePath: domain.apiMapping.ApiMappingKey || globals_1.default.defaultBasePath,
                    domainName: domain.givenDomainName,
                    patchOperations: [{
                            op: "replace",
                            path: "/basePath",
                            value: domain.basePath,
                        }]
                };
                // Make API call
                try {
                    yield (0, utils_1.throttledCall)(this.apiGateway, "updateBasePathMapping", params);
                    globals_1.default.logInfo(`Updated API mapping from '${domain.apiMapping.ApiMappingKey}'
                    to '${domain.basePath}' for '${domain.givenDomainName}'`);
                }
                catch (err) {
                    throw new Error(`Unable to update base path mapping for '${domain.givenDomainName}':\n${err.message}`);
                }
            }
            else { // Use ApiGatewayV2 for Regional domains
                const params = {
                    ApiId: domain.apiId,
                    ApiMappingId: domain.apiMapping.ApiMappingId,
                    ApiMappingKey: domain.basePath,
                    DomainName: domain.givenDomainName,
                    Stage: domain.apiType === globals_1.default.apiTypes.http ? globals_1.default.defaultStage : domain.stage,
                };
                // Make API call
                try {
                    yield (0, utils_1.throttledCall)(this.apiGatewayV2, "updateApiMapping", params);
                    globals_1.default.logInfo(`Updated API mapping to '${domain.basePath}' for '${domain.givenDomainName}'`);
                }
                catch (err) {
                    throw new Error(`Unable to update base path mapping for '${domain.givenDomainName}':\n${err.message}`);
                }
            }
        });
    }
    /**
     * Deletes basepath mapping
     */
    deleteBasePathMapping(domain) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = {
                ApiMappingId: domain.apiMapping.ApiMappingId,
                DomainName: domain.givenDomainName,
            };
            // Make API call
            try {
                yield (0, utils_1.throttledCall)(this.apiGatewayV2, "deleteApiMapping", params);
                globals_1.default.logInfo(`Removed API Mapping with id: '${domain.apiMapping.ApiMappingId}'`);
            }
            catch (err) {
                throw new Error(`Unable to remove base path mapping for '${domain.givenDomainName}':\n${err.message}`);
            }
        });
    }
}
module.exports = APIGatewayWrapper;
