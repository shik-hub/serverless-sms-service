"use strict";
/**
 * Wrapper class for Custom Domain information
 */
const globals_1 = require("./globals");
const utils_1 = require("./utils");
class DomainConfig {
    constructor(config) {
        var _a, _b, _c, _d, _e, _f, _g;
        this.enabled = (0, utils_1.evaluateBoolean)(config.enabled, true);
        this.givenDomainName = config.domainName;
        this.certificateArn = config.certificateArn;
        this.certificateName = config.certificateName;
        this.createRoute53Record = (0, utils_1.evaluateBoolean)(config.createRoute53Record, true);
        this.createRoute53IPv6Record = (0, utils_1.evaluateBoolean)(config.createRoute53IPv6Record, true);
        this.route53Profile = config.route53Profile;
        this.route53Region = config.route53Region;
        this.hostedZoneId = config.hostedZoneId;
        this.hostedZonePrivate = config.hostedZonePrivate;
        this.allowPathMatching = config.allowPathMatching;
        this.autoDomain = (0, utils_1.evaluateBoolean)(config.autoDomain, false);
        this.autoDomainWaitFor = config.autoDomainWaitFor;
        this.preserveExternalPathMappings = (0, utils_1.evaluateBoolean)(config.preserveExternalPathMappings, false);
        let basePath = config.basePath;
        if (!basePath || basePath.trim() === "") {
            basePath = globals_1.default.defaultBasePath;
        }
        this.basePath = basePath;
        let stage = config.stage;
        if (!stage) {
            stage = globals_1.default.options.stage || globals_1.default.serverless.service.provider.stage;
        }
        this.stage = stage;
        const endpointTypeWithDefault = config.endpointType || globals_1.default.endpointTypes.edge;
        const endpointTypeToUse = globals_1.default.endpointTypes[endpointTypeWithDefault.toLowerCase()];
        if (!endpointTypeToUse) {
            throw new Error(`${endpointTypeWithDefault} is not supported endpointType, use EDGE or REGIONAL.`);
        }
        this.endpointType = endpointTypeToUse;
        const apiTypeWithDefault = config.apiType || globals_1.default.apiTypes.rest;
        const apiTypeToUse = globals_1.default.apiTypes[apiTypeWithDefault.toLowerCase()];
        if (!apiTypeToUse) {
            throw new Error(`${apiTypeWithDefault} is not supported api type, use REST, HTTP or WEBSOCKET.`);
        }
        this.apiType = apiTypeToUse;
        const isEdgeType = this.endpointType === globals_1.default.endpointTypes.edge;
        if (isEdgeType && config.tlsTruststoreUri) {
            throw new Error(`${this.endpointType} APIs do not support mutual TLS, remove tlsTruststoreUri or change to a regional API.`);
        }
        if (config.tlsTruststoreUri) {
            this.validateS3Uri(config.tlsTruststoreUri);
        }
        this.tlsTruststoreUri = config.tlsTruststoreUri;
        this.tlsTruststoreVersion = config.tlsTruststoreVersion;
        const securityPolicyDefault = config.securityPolicy || globals_1.default.tlsVersions.tls_1_2;
        const tlsVersionToUse = globals_1.default.tlsVersions[securityPolicyDefault.toLowerCase()];
        if (!tlsVersionToUse) {
            throw new Error(`${securityPolicyDefault} is not a supported securityPolicy, use tls_1_0 or tls_1_2.`);
        }
        this.securityPolicy = tlsVersionToUse;
        const defaultRoutingPolicy = globals_1.default.routingPolicies.simple;
        const routingPolicy = (_c = (_b = (_a = config.route53Params) === null || _a === void 0 ? void 0 : _a.routingPolicy) === null || _b === void 0 ? void 0 : _b.toLowerCase()) !== null && _c !== void 0 ? _c : defaultRoutingPolicy;
        const routingPolicyToUse = globals_1.default.routingPolicies[routingPolicy];
        if (!routingPolicyToUse) {
            throw new Error(`${routingPolicy} is not a supported routing policy, use simple, latency, or weighted.`);
        }
        if (routingPolicyToUse !== defaultRoutingPolicy && endpointTypeToUse === globals_1.default.endpointTypes.edge) {
            throw new Error(`${routingPolicy} routing is not intended to be used with edge endpoints. ` +
                "Use a regional endpoint instead.");
        }
        this.route53Params = {
            routingPolicy: routingPolicyToUse,
            setIdentifier: (_d = config.route53Params) === null || _d === void 0 ? void 0 : _d.setIdentifier,
            weight: (_f = (_e = config.route53Params) === null || _e === void 0 ? void 0 : _e.weight) !== null && _f !== void 0 ? _f : 200,
            healthCheckId: (_g = config.route53Params) === null || _g === void 0 ? void 0 : _g.healthCheckId
        };
        this.splitHorizonDns = !this.hostedZoneId && !this.hostedZonePrivate && (0, utils_1.evaluateBoolean)(config.splitHorizonDns, false);
    }
    validateS3Uri(uri) {
        const { protocol, pathname } = new URL(uri);
        if (protocol !== "s3:" && !pathname.substring(1).includes("/")) {
            throw new Error(`${uri} is not a valid s3 uri, try something like s3://bucket-name/key-name.`);
        }
    }
}
module.exports = DomainConfig;
